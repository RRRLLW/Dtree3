<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grand Luxury Tree v5.1 ()</title>
    <style>
        /* --- åŸºç¡€æ ·å¼ä¸å­—ä½“ --- */
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Songti SC', 'SimSun', 'Times New Roman', serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* å¼•å…¥è¡¬çº¿å­—ä½“ */
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&family=Great+Vibes&display=swap');

        /* --- UI å±‚ --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
        }
        
        .ui-hidden { opacity: 0; pointer-events: none !important; }
        .hidden { display: none !important; }

        /* --- åŠ è½½åŠ¨ç”» (Loader) --- */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.8s ease-out;
        }
        .loader-text {
            color: #d4af37; font-size: 14px; letter-spacing: 4px; margin-top: 20px;
            text-transform: uppercase; font-weight: 100;
        }
        .spinner {
            width: 40px; height: 40px; border: 1px solid rgba(212, 175, 55, 0.2); 
            border-top: 1px solid #d4af37; border-radius: 50%; 
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

      

        #dedication-text {
            font-family: 'Great Vibes', 'Dancing Script', cursive;
            color: #ffccdd;
            font-size: 28px;
            text-shadow: 
                0 0 10px rgba(255, 105, 180, 0.7),
                0 0 20px rgba(255, 182, 193, 0.5),
                0 0 30px rgba(255, 192, 203, 0.3);
            margin: 0;
            padding: 10px 20px;
            background: rgba(40, 10, 30, 0.3);
            border-radius: 15px;
            border: 1px solid rgba(255, 182, 193, 0.4);
            backdrop-filter: blur(5px);
            letter-spacing: 1px;
        }

        #subtitle {
            font-family: 'Microsoft YaHei', sans-serif;
            color: #a8e6cf;
            font-size: 14px;
            margin-top: 8px;
            padding: 5px 15px;
            background: rgba(20, 40, 30, 0.3);
            border-radius: 10px;
            border: 1px solid rgba(168, 230, 207, 0.3);
            letter-spacing: 2px;
            font-weight: 300;
        }

        @keyframes gentleFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
        }

        @keyframes heartBeat {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* --- æ ‡é¢˜ (é¡¶éƒ¨å±…ä¸­) --- */
        h1 { 
            position: absolute; top: 20px; width: 100%; text-align: center;
            color: #fceea7; font-size: 48px; margin: 0; font-weight: 400; 
            letter-spacing: 6px; pointer-events: none;
            text-shadow: 0 0 50px rgba(252, 238, 167, 0.6); 
            background: linear-gradient(to bottom, #fff, #eebb66);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            font-family: 'Cinzel', serif; opacity: 0.9;
        }

        /* --- å³ä¸Šè§’ï¼šå…¨å±æ§åˆ¶ --- */
        #top-right-controls {
            position: absolute; top: 30px; right: 30px;
            pointer-events: auto; z-index: 20;
        }

        /* --- å·¦ä¸‹è§’ï¼šä¸»è¦åŠŸèƒ½åŒº --- */
        .controls-container {
            position: absolute; bottom: 30px; left: 30px;
            pointer-events: auto;
            display: flex; flex-direction: column; gap: 15px;
            align-items: flex-start;
            transition: opacity 0.5s ease;
        }

        /* --- å¥¢åæŒ‰é’®æ ·å¼ (åŠé€æ˜ç£¨ç ‚) --- */
        .elegant-btn {
            background: rgba(20, 20, 20, 0.7); 
            border: 1px solid rgba(212, 175, 55, 0.5); 
            color: #d4af37; 
            padding: 10px 20px; 
            cursor: pointer; 
            text-transform: uppercase; 
            letter-spacing: 2px; 
            font-size: 12px;
            transition: all 0.3s;
            display: inline-flex; align-items: center; justify-content: center;
            backdrop-filter: blur(5px);
            text-decoration: none;
            min-width: 100px;
            font-family: 'Microsoft YaHei', sans-serif;
        }
        .elegant-btn:hover { 
            background: #d4af37; color: #000; 
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.5);
        }

        .hint-text {
            color: rgba(212, 175, 55, 0.6); font-size: 10px; margin-top: 5px;
            letter-spacing: 1px;
        }

        /* --- å³ä¸‹è§’ï¼šæ‘„åƒå¤´é¢„è§ˆ --- */
        #webcam-wrapper {
            position: absolute; bottom: 30px; right: 30px;
            width: 160px; height: 120px;
            border: 1px solid rgba(212, 175, 55, 0.6);
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.8);
            overflow: hidden; z-index: 20; pointer-events: none;
            background: #000;
        }
        #webcam {
            width: 100%; height: 100%; object-fit: cover;
            transform: scaleX(-1); /* é•œé¢ç¿»è½¬ */
            opacity: 0.8;
        }
        #cam-status {
            position: absolute; bottom: 5px; right: 5px;
            width: 8px; height: 8px; background: red;
            border-radius: 50%; box-shadow: 0 0 5px red;
        }
        #cam-status.active { background: #00ff00; box-shadow: 0 0 5px #00ff00; }
        
        /* --- æ‰‹åŠ¿æç¤ºä¿¡æ¯ --- */
        #gesture-hint {
            position: absolute; bottom: 10px; width: 100%; text-align: center;
            color: rgba(212, 175, 55, 0.7); font-size: 12px; pointer-events: none;
            text-shadow: 0 0 5px #000;
        }

        /* --- ç…§ç‰‡åˆ é™¤ç®¡ç†å¼¹çª— --- */
        #delete-manager {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 50;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto;
        }
        #photo-grid {
            display: flex; flex-wrap: wrap; gap: 20px; max-width: 80%; max-height: 70%;
            overflow-y: auto; justify-content: center; padding: 20px;
        }
        .photo-item {
            width: 100px; height: 100px; position: relative;
            border: 1px solid #d4af37;
        }
        .photo-thumb { width: 100%; height: 100%; object-fit: cover; }
        .delete-x {
            position: absolute; top: -10px; right: -10px;
            width: 24px; height: 24px; background: #990000; color: white;
            border-radius: 50%; text-align: center; line-height: 24px;
            cursor: pointer; font-weight: bold; border: 1px solid white;
        }
        .manager-title { color: #d4af37; font-size: 24px; margin-bottom: 20px; }

        /* --- ç‰¹æ®Šç²’å­æ•ˆæœ --- */
        .heart-particle {
            position: absolute;
            font-size: 20px;
            color: #ff6b9d;
            pointer-events: none;
            z-index: 5;
            opacity: 0;
            animation: heartFloat 4s ease-in forwards;
        }

        @keyframes heartFloat {
            0% {
                opacity: 0.8;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-100px) scale(0.5);
            }
        }

        /* å“åº”å¼è°ƒæ•´ */
        @media (max-width: 768px) {
            #dedication-to-jingjing {
                top: 15px;
                left: 15px;
            }
            
            #dedication-text {
                font-size: 22px;
                padding: 8px 16px;
            }
            
            #subtitle {
                font-size: 12px;
                padding: 4px 12px;
            }
            
            h1 {
                font-size: 36px;
                top: 80px;
            }
        }

    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div class="loader-text">Loading Holiday Magic</div>
    </div>

    <div id="canvas-container"></div>

    <!-- èƒŒæ™¯éŸ³ä¹æ’­æ”¾å™¨ -->
    <audio id="background-music" loop preload="auto" style="display: none;">
        æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘æ’­æ”¾ã€‚
    </audio>

    <div id="ui-layer">
        <!-- å·¦ä¸Šè§’ï¼šç»™æ¨è€å¸ˆçš„æ ‡ç­¾ -->
        <div id="dedication-to-jingjing">
            <div id="dedication-text"></div>
        </div>
        
        <h1>Merry Christmas</h1>

        <!-- å³ä¸Šè§’ï¼šå…¨å±æ§åˆ¶ -->
        <div id="top-right-controls">
            <button class="elegant-btn" id="fs-btn" onclick="toggleFullScreen()">
                â›¶ å…¨å±æ˜¾ç¤º
            </button>
        </div>

       
    
    <div id="gesture-hint">Waiting for hand...</div>

    <div id="webcam-wrapper">
        <video id="webcam" autoplay playsinline muted></video>
        <div id="cam-status"></div>
    </div>

    <div id="delete-manager" class="hidden">
        <div class="manager-title">ç‚¹å‡»çº¢è‰²æŒ‰é’®åˆ é™¤ç…§ç‰‡</div>
        <div id="photo-grid"></div>
        <button class="elegant-btn" style="margin-top: 20px;" onclick="closeDeleteManager()">å®Œæˆ / è¿”å›</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js'; 
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- é…ç½®é¡¹ (v5.1 Specs) ---
        const CONFIG = {
            colors: { bg: 0x000000, champagneGold: 0xffd966, deepGreen: 0x03180a, accentRed: 0x990000 },
            particles: { count: 1500, dustCount: 2500, treeHeight: 24, treeRadius: 8 },
            camera: { z: 50 },
            interaction: {
                rotationSpeed: 1.4,    // æ—‹è½¬é€Ÿç‡ç³»æ•°
                grabRadius: 0.75,      // æŠ“å–åˆ¤å®šåŠå¾„
                zoomScale: 2.8         // ç…§ç‰‡æ”¾å¤§å€æ•°
            }
        };

        const STATE = {
            mode: 'TREE', // TREE, SCATTER, FOCUS
            focusTarget: null,
            hand: { detected: false, x: 0, y: 0 },
            rotation: { x: 0, y: 0 } 
        };

        // --- éŸ³é¢‘ç›¸å…³å˜é‡ ---
        let bgmAudio = document.getElementById('background-music');
        let isMusicPlaying = false;
        
        // ==============================================
        // === åœ¨è¿™é‡Œé¢„è®¾ç…§ç‰‡å’ŒéŸ³ä¹è·¯å¾„ ===
        // ==============================================
        
        // 1. é¢„è®¾éŸ³ä¹æ–‡ä»¶è·¯å¾„
        const PRESET_MUSIC_PATH = './å±±ä¸‹é”éƒ (ã‚„ã¾ã—ãŸ ãŸã¤ã‚ã†)-ã‚¯ãƒªã‚¹ãƒã‚¹ãƒ»ã‚¤ãƒ–.mp3';
        
        // 2. é¢„è®¾ç…§ç‰‡æ–‡ä»¶è·¯å¾„æ•°ç»„ï¼ˆåœ¨è¿™é‡Œæ·»åŠ ä½ çš„ç…§ç‰‡è·¯å¾„ï¼‰
        const PRESET_PHOTOS = [
            // ç¤ºä¾‹è·¯å¾„ - è¯·æ›¿æ¢ä¸ºä½ çš„å®é™…ç…§ç‰‡è·¯å¾„
            './photos/photo1.jpg',
            './photos/photo2.jpg',
            './photos/photo3.jpg',
            './photos/photo4.jpg',
            './photos/photo5.jpg',
            // å¯ä»¥ç»§ç»­æ·»åŠ æ›´å¤šç…§ç‰‡...
            // './photos/photo6.jpg',
            // './photos/photo7.jpg',
            // './photos/photo8.jpg',
        ];
        
        // 3. å¤‡é€‰ç…§ç‰‡ï¼ˆå½“é¢„è®¾ç…§ç‰‡åŠ è½½å¤±è´¥æ—¶ä½¿ç”¨ï¼‰
        const FALLBACK_PHOTOS = [
            // è¿™é‡Œå¯ä»¥æ·»åŠ ä¸€äº›åœ¨çº¿ç…§ç‰‡ä½œä¸ºå¤‡é€‰
            'https://69392e5868e5054fafcddbd4.imgix.net/0a2c34ef414794c80740f58afd910df3.jpg?fit=crop&w=192.195&h=154&dpr=2&q=50&auto=format%2Ccompress&cacheID=1765834515?w=400&h=400&fit=crop',
            'https://69392e5868e5054fafcddbd4.imgix.net/c98a72aeb52e16d7ce2401b232fdf60d.jpg?fit=crop&w=192.203&h=154&dpr=2&q=50&auto=format%2Ccompress&cacheID=1765838515?w=400&h=400&fit=crop',
            'https://69392e5868e5054fafcddbd4.imgix.net/64f012ca54298243b76c8c731dcfd76d.jpg?fit=crop&w=192.195&h=154&dpr=2&q=50&auto=format%2Ccompress&cacheID=1765520760?w=400&h=400&fit=crop',
            'https://69392e5868e5054fafcddbd4.imgix.net/9d25e7bf00ac97bb7b8fe0c76eea02e8.jpg?fit=crop&w=192.203&h=154&dpr=2&q=50&auto=format%2Ccompress&cacheID=1765649300?w=400&h=400&fit=crop',
            'https://69392e5868e5054fafcddbd4.imgix.net/f4fde99a4fa70d11a0c6bf673fae4abe.jpg?fit=crop&w=192.195&h=154&dpr=2&q=50&auto=format%2Ccompress&cacheID=1765815908?w=400&h=400&fit=crop',
           
];
        
        // ==============================================
        
        let scene, camera, renderer, composer;
        let mainGroup; 
        let clock = new THREE.Clock();
        let particleSystem = []; 
        let photoMeshGroup = new THREE.Group();
        let handLandmarker, video;
        let caneTexture; 
        let heartAnimationTimer = null;

        async function init() {
            initThree();
            setupEnvironment(); 
            setupLights();
            createTextures();
            createParticles(); 
            createDust();      
            createDefaultPhotos();
            setupPostProcessing();
            setupEvents();
            await initMediaPipe();
            
            // ç§»é™¤ Loading
            const loader = document.getElementById('loader');
            loader.style.opacity = 0;
            setTimeout(() => loader.remove(), 800);
            
            // å¯åŠ¨çˆ±å¿ƒç²’å­æ•ˆæœ
            startHeartParticleEffect();
            
            // è‡ªåŠ¨åŠ è½½é¢„è®¾éŸ³ä¹å’Œç…§ç‰‡
            setTimeout(() => {
                loadPresetMusicAndPhotos();
            }, 1000);
            
            animate();
        }

        // --- è‡ªåŠ¨åŠ è½½é¢„è®¾éŸ³ä¹å’Œç…§ç‰‡ ---
        async function loadPresetMusicAndPhotos() {
            console.log('å¼€å§‹åŠ è½½é¢„è®¾éŸ³ä¹å’Œç…§ç‰‡...');
            
            // 1. åŠ è½½é¢„è®¾éŸ³ä¹
            if (PRESET_MUSIC_PATH) {
                try {
                    console.log('åŠ è½½éŸ³ä¹:', PRESET_MUSIC_PATH);
                    initAudioSystem(PRESET_MUSIC_PATH);
                    
                    // å»¶è¿Ÿæ’­æ”¾éŸ³ä¹
                    setTimeout(() => {
                        if (bgmAudio.src && !isMusicPlaying) {
                            playMusic();
                        }
                    }, 1500);
                } catch (error) {
                    console.error('åŠ è½½éŸ³ä¹å¤±è´¥:', error);
                }
            }
            
            // 2. åŠ è½½é¢„è®¾ç…§ç‰‡
            console.log(`å¼€å§‹åŠ è½½ ${PRESET_PHOTOS.length} å¼ é¢„è®¾ç…§ç‰‡...`);
            
            // æ˜¾ç¤ºåŠ è½½æç¤º
            const loader = document.createElement('div');
            loader.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.9);
                color: #d4af37;
                padding: 20px;
                border-radius: 10px;
                border: 2px solid #d4af37;
                z-index: 1000;
                text-align: center;
            `;
            loader.innerHTML = `<div>ğŸ„ æ­£åœ¨åŠ è½½ç¾å¥½å›å¿†...</div>`;
            document.body.appendChild(loader);
            
            let loadedCount = 0;
            let failedCount = 0;
            
            // ä½¿ç”¨Promise.allå¹¶è¡ŒåŠ è½½æ‰€æœ‰ç…§ç‰‡
            const loadPromises = PRESET_PHOTOS.map(async (photoPath, index) => {
                try {
                    await loadPresetPhoto(photoPath, index + 1);
                    loadedCount++;
                    
                    // æ›´æ–°åŠ è½½æç¤º
                    loader.innerHTML = `<div>ğŸ„ æ­£åœ¨åŠ è½½ç¾å¥½å›å¿†... ${loadedCount}/${PRESET_PHOTOS.length}</div>`;
                    
                    // æ¯å¼ ç…§ç‰‡ä¹‹é—´æ·»åŠ çŸ­æš‚å»¶è¿Ÿä»¥é¿å…é˜»å¡
                    await new Promise(resolve => setTimeout(resolve, 100));
                } catch (error) {
                    console.error(`åŠ è½½é¢„è®¾ç…§ç‰‡å¤±è´¥ ${index + 1}:`, photoPath, error);
                    failedCount++;
                    
                    // å¦‚æœé¢„è®¾ç…§ç‰‡åŠ è½½å¤±è´¥ï¼Œå°è¯•åŠ è½½å¤‡é€‰ç…§ç‰‡
                    if (index < FALLBACK_PHOTOS.length) {
                        try {
                            await loadPresetPhoto(FALLBACK_PHOTOS[index], index + 1);
                            loadedCount++;
                            loader.innerHTML = `<div>ğŸ„ æ­£åœ¨åŠ è½½å¤‡é€‰ç…§ç‰‡... ${loadedCount}/${PRESET_PHOTOS.length}</div>`;
                        } catch (fallbackError) {
                            console.error(`å¤‡é€‰ç…§ç‰‡ä¹ŸåŠ è½½å¤±è´¥:`, fallbackError);
                        }
                    }
                }
            });
            
            // ç­‰å¾…æ‰€æœ‰ç…§ç‰‡åŠ è½½å®Œæˆ
            await Promise.all(loadPromises);
            
            // ç§»é™¤åŠ è½½æç¤º
            setTimeout(() => {
                loader.remove();
            }, 1000);
            
            console.log(`ç…§ç‰‡åŠ è½½å®Œæˆ: ${loadedCount} å¼ æˆåŠŸ, ${failedCount} å¼ å¤±è´¥`);
            
            // å¦‚æœæ²¡æœ‰åŠ è½½åˆ°ä»»ä½•ç…§ç‰‡ï¼Œåˆ›å»ºä¸€äº›é»˜è®¤ç…§ç‰‡
            if (loadedCount === 0) {
                console.log('æ²¡æœ‰ç…§ç‰‡åŠ è½½æˆåŠŸï¼Œåˆ›å»ºé»˜è®¤ç…§ç‰‡...');
                for (let i = 0; i < 3; i++) {
                    createSpecialPhoto(i);
                }
            }
        }
        
        // --- åŠ è½½é¢„è®¾ç…§ç‰‡ ---
        function loadPresetPhoto(path, photoNumber) {
            return new Promise((resolve, reject) => {
                const loader = new THREE.TextureLoader();
                
                // è®¾ç½®è¶…æ—¶æ—¶é—´
                const timeout = setTimeout(() => {
                    reject(new Error(`åŠ è½½è¶…æ—¶: ${path}`));
                }, 10000);
                
                loader.load(
                    path,
                    (texture) => {
                        clearTimeout(timeout);
                        texture.colorSpace = THREE.SRGBColorSpace;
                        
                        // æ·»åŠ ç…§ç‰‡åˆ°åœºæ™¯ï¼Œä¿æŒåŸæœ‰æ ¼å¼
                        addPhotoToScene(texture, `é¢„è®¾ç…§ç‰‡ ${photoNumber}`);
                        console.log(`æˆåŠŸåŠ è½½é¢„è®¾ç…§ç‰‡ ${photoNumber}: ${path}`);
                        resolve();
                    },
                    (progress) => {
                        // åŠ è½½è¿›åº¦å›è°ƒï¼ˆå¯é€‰ï¼‰
                        console.log(`åŠ è½½è¿›åº¦ ${photoNumber}: ${(progress.loaded / progress.total * 100).toFixed(1)}%`);
                    },
                    (error) => {
                        clearTimeout(timeout);
                        reject(error);
                    }
                );
            });
        }
        
        // --- åˆ›å»ºç‰¹æ®Šç…§ç‰‡ï¼ˆå½“é¢„è®¾ç…§ç‰‡åŠ è½½å¤±è´¥æ—¶ä½¿ç”¨ï¼‰ ---
        function createSpecialPhoto(index) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // åˆ›å»ºæ¸å˜èƒŒæ™¯
            const gradient = ctx.createLinearGradient(0, 0, 512, 512);
            const colors = [
                ['#1a472a', '#0c2d1a'],
                ['#2d1b69', '#1a1033'],
                ['#472a1a', '#2d1a0c']
            ];
            
            gradient.addColorStop(0, colors[index % colors.length][0]);
            gradient.addColorStop(1, colors[index % colors.length][1]);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            
            // æ·»åŠ è£…é¥°è¾¹æ¡†
            ctx.strokeStyle = '#d4af37';
            ctx.lineWidth = 10;
            ctx.strokeRect(20, 20, 472, 472);
            
            // æ·»åŠ çˆ±å¿ƒ
            ctx.fillStyle = '#ff6b9d';
            ctx.beginPath();
            for (let i = 0; i < 3; i++) {
                const x = 128 + i * 128;
                const y = 200;
                const size = 50;
                
                ctx.moveTo(x, y);
                ctx.bezierCurveTo(x, y - size/2, x + size/2, y - size, x + size, y - size/2);
                ctx.bezierCurveTo(x + size, y, x + size/2, y + size/2, x, y + size);
                ctx.bezierCurveTo(x - size/2, y + size/2, x - size, y, x - size, y - size/2);
                ctx.bezierCurveTo(x - size/2, y - size, x, y - size/2, x, y);
            }
            ctx.fill();
            
            // æ·»åŠ æ–‡å­—
            ctx.fillStyle = '#d4af37';
            ctx.font = 'bold 40px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ğŸ’–æ¨è€å¸ˆ ğŸ’–', 256, 350);
            ctx.font = 'italic 30px Arial';
            ctx.fillText('åœ£è¯å¿«ä¹', 256, 400);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.colorSpace = THREE.SRGBColorSpace;
            addPhotoToScene(texture, `ç‰¹æ®Šç…§ç‰‡ ${index + 1}`);
        }

        // --- éŸ³é¢‘ç³»ç»Ÿåˆå§‹åŒ– ---
        function initAudioSystem(musicPath = '') {
            if (musicPath) {
                bgmAudio.src = musicPath;
                bgmAudio.load();
                
                bgmAudio.oncanplaythrough = () => {
                    console.log('èƒŒæ™¯éŸ³ä¹åŠ è½½å®Œæˆ');
                };
                
                bgmAudio.onerror = (error) => {
                    console.error('éŸ³ä¹åŠ è½½å¤±è´¥:', error);
                    // å¦‚æœé¢„è®¾éŸ³ä¹åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨åœ¨çº¿å¤‡é€‰éŸ³ä¹
                    loadFallbackMusic();
                };
            } else {
                // å¦‚æœæ²¡æœ‰æŒ‡å®šéŸ³ä¹ï¼Œä½¿ç”¨åœ¨çº¿å¤‡é€‰éŸ³ä¹
                loadFallbackMusic();
            }
        }
        
        // --- å¤‡é€‰éŸ³ä¹ ---
        function loadFallbackMusic() {
            console.log('ä½¿ç”¨åœ¨çº¿å¤‡é€‰éŸ³ä¹...');
            const fallbackMusic = 'https://assets.mixkit.co/music/preview/mixkit-christmas-magic-1115.mp3';
            bgmAudio.src = fallbackMusic;
            bgmAudio.load();
            
            setTimeout(() => {
                if (!isMusicPlaying) {
                    playMusic();
                }
            }, 2000);
        }

        // --- éŸ³ä¹æ§åˆ¶å‡½æ•° ---
        window.toggleMusic = function() {
            if (!bgmAudio.src) {
                return;
            }
            
            if (isMusicPlaying) {
                pauseMusic();
            } else {
                playMusic();
            }
        }

        function playMusic() {
            if (!bgmAudio.src) {
                return;
            }
            
            const playPromise = bgmAudio.play();
            
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    isMusicPlaying = true;
                    console.log('èƒŒæ™¯éŸ³ä¹å¼€å§‹æ’­æ”¾');
                }).catch(error => {
                    console.warn('è‡ªåŠ¨æ’­æ”¾è¢«é˜»æ­¢ï¼Œéœ€è¦ç”¨æˆ·äº¤äº’:', error);
                    showMusicPlayHint();
                });
            }
        }

        function pauseMusic() {
            bgmAudio.pause();
            isMusicPlaying = false;
            console.log('èƒŒæ™¯éŸ³ä¹å·²æš‚åœ');
        }

        // æ˜¾ç¤ºéŸ³ä¹æ’­æ”¾æç¤º
        function showMusicPlayHint() {
            const hint = document.createElement('div');
            hint.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.9);
                color: #d4af37;
                padding: 20px;
                border-radius: 10px;
                border: 2px solid #d4af37;
                z-index: 1000;
                text-align: center;
                backdrop-filter: blur(10px);
                animation: gentleFloat 2s ease-in-out infinite;
            `;
            hint.innerHTML = `
                <h3 style="margin: 0 0 10px 0;">ğŸµ ç»™æ¨è€å¸ˆçš„ç‰¹åˆ«éŸ³ä¹</h3>
                <p style="margin: 0; font-size: 12px; color: #eebb66;">ç‚¹å‡»å±å¹•å¼€å§‹æ’­æ”¾</p>
                <div style="margin-top: 15px; font-size: 10px; color: #aaa;">ğŸ’ åœ£è¯å¿«ä¹ ğŸ’</div>
            `;
            
            document.body.appendChild(hint);
            
            // ç‚¹å‡»æç¤ºå¼€å§‹éŸ³ä¹
            hint.addEventListener('click', () => {
                startMusicWithInteraction();
                hint.remove();
            });
            
            // 5ç§’åè‡ªåŠ¨ç§»é™¤æç¤º
            setTimeout(() => {
                if (hint.parentNode) {
                    hint.parentNode.removeChild(hint);
                }
            }, 5000);
        }

        // é€šè¿‡ç”¨æˆ·äº¤äº’å¯åŠ¨éŸ³ä¹
        window.startMusicWithInteraction = function() {
            const playPromise = bgmAudio.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    isMusicPlaying = true;
                    console.log('èƒŒæ™¯éŸ³ä¹å¼€å§‹æ’­æ”¾');
                }).catch(error => {
                    console.error('æ’­æ”¾å¤±è´¥:', error);
                });
            }
        };

        // --- å·¦ä¸Šè§’æ ‡ç­¾çš„ç‰¹æ®Šæ•ˆæœ ---
        function startHeartParticleEffect() {
            const dedicationElement = document.getElementById('dedication-to-jingjing');
            
            heartAnimationTimer = setInterval(() => {
                createHeartParticle(dedicationElement);
            }, 2000);

            dedicationElement.style.pointerEvents = 'auto';
            dedicationElement.style.cursor = 'pointer';
            
            dedicationElement.addEventListener('mouseenter', () => {
                clearInterval(heartAnimationTimer);
                heartAnimationTimer = setInterval(() => {
                    createHeartParticle(dedicationElement);
                    createHeartParticle(dedicationElement);
                }, 500);
                
                dedicationElement.style.animation = 'heartBeat 0.5s ease';
                setTimeout(() => {
                    dedicationElement.style.animation = 'gentleFloat 4s ease-in-out infinite';
                }, 500);
            });
            
            dedicationElement.addEventListener('mouseleave', () => {
                clearInterval(heartAnimationTimer);
                heartAnimationTimer = setInterval(() => {
                    createHeartParticle(dedicationElement);
                }, 2000);
            });

            dedicationElement.addEventListener('click', () => {
                createSpecialHeartInScene();
            });
            
            dedicationElement.addEventListener('click', () => {
                if (!isMusicPlaying && bgmAudio.src) {
                    startMusicWithInteraction();
                }
            });
        }

        function createHeartParticle(parentElement) {
            const heart = document.createElement('div');
            heart.className = 'heart-particle';
            heart.innerHTML = 'â¤ï¸';
            
            const x = Math.random() * parentElement.offsetWidth;
            const y = parentElement.offsetHeight;
            
            heart.style.left = `${x}px`;
            heart.style.top = `${y}px`;
            
            const size = 15 + Math.random() * 20;
            heart.style.fontSize = `${size}px`;
            
            const colors = ['#ff6b9d', '#ff8fab', '#ffb3c6', '#ffccdd', '#ff6b6b'];
            heart.style.color = colors[Math.floor(Math.random() * colors.length)];
            
            parentElement.appendChild(heart);
            
            setTimeout(() => {
                heart.remove();
            }, 4000);
        }

        function createSpecialHeartInScene() {
            const heartShape = new THREE.Shape();
            heartShape.moveTo(0, 0.5);
            heartShape.bezierCurveTo(0, 1, 1, 1, 1, 0.5);
            heartShape.bezierCurveTo(1, 0, 0.5, -0.5, 0, -0.5);
            heartShape.bezierCurveTo(-0.5, -0.5, -1, 0, -1, 0.5);
            heartShape.bezierCurveTo(-1, 1, 0, 1, 0, 0.5);
            
            const extrudeSettings = {
                depth: 0.2,
                bevelEnabled: true,
                bevelSegments: 2,
                steps: 2,
                bevelSize: 0.1,
                bevelThickness: 0.1
            };
            
            const heartGeometry = new THREE.ExtrudeGeometry(heartShape, extrudeSettings);
            const heartMaterial = new THREE.MeshStandardMaterial({
                color: 0xff6b9d,
                emissive: 0xff3366,
                emissiveIntensity: 0.5,
                metalness: 0.8,
                roughness: 0.2
            });
            
            const heartMesh = new THREE.Mesh(heartGeometry, heartMaterial);
            heartMesh.scale.set(1.5, 1.5, 1.5);
            heartMesh.position.set(
                (Math.random() - 0.5) * 10,
                5 + Math.random() * 5,
                (Math.random() - 0.5) * 10
            );
            
            scene.add(heartMesh);
            
            let life = 3;
            function animateHeart() {
                life -= 0.016;
                if (life > 0) {
                    heartMesh.position.y += 0.1;
                    heartMesh.scale.multiplyScalar(0.98);
                    heartMesh.rotation.y += 0.05;
                    requestAnimationFrame(animateHeart);
                } else {
                    scene.remove(heartMesh);
                }
            }
            animateHeart();
        }

        // --- Three.js åœºæ™¯åˆå§‹åŒ– ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.bg);
            scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.01); 

            camera = new THREE.PerspectiveCamera(42, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, CONFIG.camera.z); 

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping; 
            renderer.toneMappingExposure = 2.2; 
            container.appendChild(renderer.domElement);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);
        }

        function setupEnvironment() {
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
        }

        function setupLights() {
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const innerLight = new THREE.PointLight(0xffaa00, 2, 20);
            innerLight.position.set(0, 5, 0);
            mainGroup.add(innerLight);
            
            const spotGold = new THREE.SpotLight(0xffcc66, 1200);
            spotGold.position.set(30, 40, 40); spotGold.angle = 0.5; spotGold.penumbra = 0.5;
            scene.add(spotGold);
            
            const spotBlue = new THREE.SpotLight(0x6688ff, 600);
            spotBlue.position.set(-30, 20, -30); scene.add(spotBlue);
            
            const fill = new THREE.DirectionalLight(0xffeebb, 0.8);
            fill.position.set(0, 0, 50); scene.add(fill);
            
            const pinkLight = new THREE.PointLight(0xff6b9d, 3, 15);
            pinkLight.position.set(-15, 10, 20);
            scene.add(pinkLight);
        }

        function setupPostProcessing() {
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.7; bloomPass.strength = 0.45; bloomPass.radius = 0.4;
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene); composer.addPass(bloomPass);
        }

        // --- çº¹ç†ä¸ç²’å­ç³»ç»Ÿ ---
        function createTextures() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,128,128);
            ctx.fillStyle = '#880000'; ctx.beginPath();
            for(let i=-128; i<256; i+=32) { ctx.moveTo(i, 0); ctx.lineTo(i+32, 128); ctx.lineTo(i+16, 128); ctx.lineTo(i-16, 0); }
            ctx.fill();
            caneTexture = new THREE.CanvasTexture(canvas);
            caneTexture.wrapS = caneTexture.wrapT = THREE.RepeatWrapping;
            caneTexture.repeat.set(3, 3);
        }

        class Particle {
            constructor(mesh, type, isDust = false) {
                this.mesh = mesh;
                this.type = type;
                this.isDust = isDust;
                this.posTree = new THREE.Vector3();
                this.posScatter = new THREE.Vector3();
                this.baseScale = mesh.scale.x; 
                this.texture = null;
                this.photoUrl = null;

                const speedMult = (type === 'PHOTO') ? 0.3 : 2.0;
                this.spinSpeed = new THREE.Vector3(
                    (Math.random() - 0.5) * speedMult, (Math.random() - 0.5) * speedMult, (Math.random() - 0.5) * speedMult
                );
                this.calculatePositions();
            }

            calculatePositions() {
                const h = CONFIG.particles.treeHeight;
                let t = Math.pow(Math.random(), 0.8); 
                const y = (t * h) - (h/2);
                let rMax = Math.max(0.5, CONFIG.particles.treeRadius * (1.0 - t));
                const angle = t * 50 * Math.PI + Math.random() * Math.PI; 
                const r = rMax * (0.8 + Math.random() * 0.4); 
                this.posTree.set(Math.cos(angle) * r, y, Math.sin(angle) * r);

                let rScatter = this.isDust ? (12 + Math.random()*20) : (8 + Math.random()*12);
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                this.posScatter.set(
                    rScatter * Math.sin(phi) * Math.cos(theta),
                    rScatter * Math.sin(phi) * Math.sin(theta),
                    rScatter * Math.cos(phi)
                );
            }

            update(dt, mode, focusTargetMesh) {
                let target = this.posTree;
                
                if (mode === 'SCATTER') target = this.posScatter;
                else if (mode === 'FOCUS') {
                    if (this.mesh === focusTargetMesh) {
                        const desiredWorldPos = new THREE.Vector3(0, 1, 38); 
                        const invMatrix = new THREE.Matrix4().copy(mainGroup.matrixWorld).invert();
                        target = desiredWorldPos.applyMatrix4(invMatrix);
                    } else {
                        target = this.posScatter;
                    }
                }

                const lerpSpeed = (mode === 'FOCUS' && this.mesh === focusTargetMesh) ? 5.0 : 2.0; 
                this.mesh.position.lerp(target, lerpSpeed * dt);

                if (mode === 'SCATTER') {
                    this.mesh.rotation.x += this.spinSpeed.x * dt;
                    this.mesh.rotation.y += this.spinSpeed.y * dt;
                    this.mesh.rotation.z += this.spinSpeed.z * dt;
                } else if (mode === 'TREE') {
                    this.mesh.rotation.x = THREE.MathUtils.lerp(this.mesh.rotation.x, 0, dt);
                    this.mesh.rotation.z = THREE.MathUtils.lerp(this.mesh.rotation.z, 0, dt);
                    this.mesh.rotation.y += 0.5 * dt; 
                }
                
                if (mode === 'FOCUS' && this.mesh === focusTargetMesh) {
                    this.mesh.lookAt(camera.position); 
                }

                let s = this.baseScale;
                if (this.isDust) {
                    s = this.baseScale * (0.8 + 0.4 * Math.sin(clock.elapsedTime * 4 + this.mesh.id));
                    if (mode === 'TREE') s = 0; 
                } else if (mode === 'SCATTER' && this.type === 'PHOTO') {
                    s = this.baseScale * 2.5;
                } else if (mode === 'FOCUS') {
                    if (this.mesh === focusTargetMesh) s = CONFIG.interaction.zoomScale;
                    else s = this.baseScale * 0.8; 
                }
                
                this.mesh.scale.lerp(new THREE.Vector3(s,s,s), 4*dt);
            }
        }

        function createParticles() {
            const sphereGeo = new THREE.SphereGeometry(0.5, 32, 32); 
            const boxGeo = new THREE.BoxGeometry(0.55, 0.55, 0.55); 
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, -0.5, 0), new THREE.Vector3(0, 0.3, 0),
                new THREE.Vector3(0.1, 0.5, 0), new THREE.Vector3(0.3, 0.4, 0)
            ]);
            const candyGeo = new THREE.TubeGeometry(curve, 16, 0.08, 8, false);

            const goldMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.champagneGold, metalness: 1.0, roughness: 0.1, envMapIntensity: 2.0, emissive: 0x443300, emissiveIntensity: 0.3 });
            const greenMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.deepGreen, metalness: 0.2, roughness: 0.8, emissive: 0x002200, emissiveIntensity: 0.2 });
            const redMat = new THREE.MeshPhysicalMaterial({ color: CONFIG.colors.accentRed, metalness: 0.3, roughness: 0.2, clearcoat: 1.0, emissive: 0x330000 });
            const candyMat = new THREE.MeshStandardMaterial({ map: caneTexture, roughness: 0.4 });

            for (let i = 0; i < CONFIG.particles.count; i++) {
                const rand = Math.random();
                let mesh, type;
                if (rand < 0.40) { mesh = new THREE.Mesh(boxGeo, greenMat); type = 'BOX'; }
                else if (rand < 0.70) { mesh = new THREE.Mesh(boxGeo, goldMat); type = 'GOLD_BOX'; }
                else if (rand < 0.92) { mesh = new THREE.Mesh(sphereGeo, goldMat); type = 'GOLD_SPHERE'; }
                else if (rand < 0.97) { mesh = new THREE.Mesh(sphereGeo, redMat); type = 'RED'; }
                else { mesh = new THREE.Mesh(candyGeo, candyMat); type = 'CANE'; }

                const s = 0.4 + Math.random() * 0.5;
                mesh.scale.set(s,s,s); mesh.rotation.set(Math.random()*6, Math.random()*6, Math.random()*6);
                mainGroup.add(mesh); particleSystem.push(new Particle(mesh, type, false));
            }

            const starGeo = new THREE.OctahedronGeometry(1.2, 0);
            const starMat = new THREE.MeshStandardMaterial({ color: 0xffdd88, emissive: 0xffaa00, emissiveIntensity: 1.0, metalness: 1.0, roughness: 0 });
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.set(0, CONFIG.particles.treeHeight/2 + 1.2, 0);
            mainGroup.add(star);
            
            mainGroup.add(photoMeshGroup);
        }

        function createDust() {
            const geo = new THREE.TetrahedronGeometry(0.08, 0);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffeebb, transparent: true, opacity: 0.8 });
            for(let i=0; i<CONFIG.particles.dustCount; i++) {
                 const mesh = new THREE.Mesh(geo, mat); mesh.scale.setScalar(0.5 + Math.random());
                 mainGroup.add(mesh); particleSystem.push(new Particle(mesh, 'DUST', true));
            }
        }

        function createDefaultPhotos() {
            const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#050505'; ctx.fillRect(0,0,512,512);
            ctx.strokeStyle = '#eebb66'; ctx.lineWidth = 15; ctx.strokeRect(20,20,472,472);
            ctx.font = '500 60px Times New Roman'; ctx.fillStyle = '#eebb66'; ctx.textAlign = 'center'; 
            ctx.fillText("JOYEUX", 256, 230); ctx.fillText("NOEL", 256, 300);
            const tex = new THREE.CanvasTexture(canvas); tex.colorSpace = THREE.SRGBColorSpace;
            addPhotoToScene(tex, 'default');
        }

        // --- æ·»åŠ ç…§ç‰‡åˆ°åœºæ™¯ï¼ˆä¿æŒåŸæœ‰æ ¼å¼ï¼‰ ---
        function addPhotoToScene(texture, photoUrl = null) {
            // åˆ›å»ºé‡‘è‰²ç›¸æ¡†ï¼ˆä¿æŒåŸæœ‰æ ¼å¼ï¼‰
            const frameGeo = new THREE.BoxGeometry(1.4, 1.4, 0.05);
            const frameMat = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.champagneGold, 
                metalness: 1.0, 
                roughness: 0.1,
                emissive: 0x443300,
                emissiveIntensity: 0.3
            });
            const frame = new THREE.Mesh(frameGeo, frameMat);
            
            // åˆ›å»ºç…§ç‰‡å¹³é¢ï¼ˆä¿æŒåŸæœ‰æ ¼å¼ï¼‰
            const photoGeo = new THREE.PlaneGeometry(1.2, 1.2);
            const photoMat = new THREE.MeshBasicMaterial({ 
                map: texture,
                side: THREE.DoubleSide
            });
            const photo = new THREE.Mesh(photoGeo, photoMat);
            photo.position.z = 0.04;
            
            // åˆ›å»ºç…§ç‰‡ç»„ï¼ˆä¿æŒåŸæœ‰æ ¼å¼ï¼‰
            const group = new THREE.Group();
            group.add(frame); 
            group.add(photo);
            
            // è®¾ç½®åˆå§‹ç¼©æ”¾ï¼ˆä¿æŒåŸæœ‰æ ¼å¼ï¼‰
            const s = 0.8; 
            group.scale.set(s,s,s);
            
            // è®¾ç½®åˆå§‹æ—‹è½¬ï¼ˆå¢åŠ ä¸€äº›éšæœºæ€§ï¼‰
            group.rotation.set(
                Math.random() * Math.PI * 0.1,
                Math.random() * Math.PI * 0.1,
                Math.random() * Math.PI * 0.05
            );
            
            // æ·»åŠ åˆ°ç…§ç‰‡ç»„
            photoMeshGroup.add(group);
            
            // åˆ›å»ºç²’å­å¯¹è±¡ï¼ˆä¿æŒåŸæœ‰æ ¼å¼ï¼‰
            const p = new Particle(group, 'PHOTO', false);
            p.texture = texture;
            p.photoUrl = photoUrl;
            particleSystem.push(p);
            
            // æ·»åŠ è½»å¾®æµ®åŠ¨åŠ¨ç”»
            animatePhotoFloat(group);
            
            return p;
        }
        
        // --- ç…§ç‰‡æµ®åŠ¨åŠ¨ç”» ---
        function animatePhotoFloat(group) {
            const startTime = Date.now();
            const floatSpeed = 0.5 + Math.random() * 0.5;
            const floatHeight = 0.05 + Math.random() * 0.1;
            
            function floatAnimation() {
                const elapsed = (Date.now() - startTime) / 1000;
                const floatOffset = Math.sin(elapsed * floatSpeed) * floatHeight;
                
                group.position.y += floatOffset * 0.01;
                
                requestAnimationFrame(floatAnimation);
            }
            
            floatAnimation();
        }
        
        // --- ç•Œé¢äº¤äº’äº‹ä»¶ ---
        function setupEvents() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
            });

            // ç›‘å¬é”®ç›˜å¿«æ·é”®
            window.addEventListener('keydown', (e) => { 
                if (e.key.toLowerCase() === 'h') {
                    const controls = document.querySelector('.controls-container');
                    const dedication = document.getElementById('dedication-to-jingjing');
                    controls.classList.toggle('ui-hidden');
                    dedication.classList.toggle('ui-hidden');
                }
                if (e.key.toLowerCase() === 'm') {
                    toggleMusic();
                }
                if (e.key === ' ') {
                    e.preventDefault();
                    toggleMusic();
                }
            });
            
            // ç‚¹å‡»é¡µé¢ä»»æ„ä½ç½®å¼€å§‹éŸ³ä¹
            document.addEventListener('click', () => {
                if (!isMusicPlaying && bgmAudio.src) {
                    startMusicWithInteraction();
                }
            });
            
            // å³é”®èœå•ç¦ç”¨ï¼ˆå¯é€‰ï¼‰
            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
        }

        // --- å…¨å±€ UI åŠŸèƒ½å‡½æ•° ---
        window.toggleFullScreen = function() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
                document.getElementById('fs-btn').innerText = "â›¶ é€€å‡ºå…¨å±";
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                    document.getElementById('fs-btn').innerText = "â›¶ å…¨å±æ˜¾ç¤º";
                }
            }
        }

        window.openDeleteManager = function() {
            const modal = document.getElementById('delete-manager');
            const grid = document.getElementById('photo-grid');
            grid.innerHTML = '';
            
            const photos = particleSystem.filter(p => p.type === 'PHOTO');
            
            if(photos.length === 0) {
                grid.innerHTML = '<div style="color:#888; padding: 20px;">æ²¡æœ‰ç…§ç‰‡å¯ç®¡ç†</div>';
            } else {
                photos.forEach((p, index) => {
                    const div = document.createElement('div');
                    div.className = 'photo-item';
                    
                    const img = document.createElement('img');
                    img.className = 'photo-thumb';
                    
                    // å°è¯•è·å–ç…§ç‰‡çš„URLæˆ–æ•°æ®
                    if (p.photoUrl && (p.photoUrl.startsWith('blob:') || p.photoUrl.startsWith('http'))) {
                        img.src = p.photoUrl;
                    } else if (p.texture.image.toDataURL) {
                        img.src = p.texture.image.toDataURL();
                    } else if (p.texture.image.src) {
                        img.src = p.texture.image.src;
                    } else {
                        // åˆ›å»ºé»˜è®¤ç¼©ç•¥å›¾
                        img.src = 'data:image/svg+xml;base64,' + btoa(`
                            <svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">
                                <rect width="100" height="100" fill="#333"/>
                                <text x="50" y="50" text-anchor="middle" dy=".3em" fill="#d4af37" font-size="12">ç…§ç‰‡ ${index+1}</text>
                            </svg>
                        `);
                    }
                    
                    const btn = document.createElement('div');
                    btn.className = 'delete-x';
                    btn.innerText = 'X';
                    btn.title = 'åˆ é™¤ç…§ç‰‡';
                    btn.onclick = () => deletePhoto(p);
                    
                    div.appendChild(img);
                    div.appendChild(btn);
                    grid.appendChild(div);
                });
            }
            modal.classList.remove('hidden');
        }

        window.closeDeleteManager = function() {
            document.getElementById('delete-manager').classList.add('hidden');
        }

        function deletePhoto(particleRef) {
            // ä»åœºæ™¯ä¸­ç§»é™¤ç…§ç‰‡
            photoMeshGroup.remove(particleRef.mesh);
            
            // ä»ç²’å­ç³»ç»Ÿä¸­ç§»é™¤
            const idx = particleSystem.indexOf(particleRef);
            if (idx > -1) particleSystem.splice(idx, 1);
            
            // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰ç„¦ç‚¹ç…§ç‰‡ï¼Œé‡ç½®çŠ¶æ€
            if(STATE.focusTarget === particleRef.mesh) {
                STATE.mode = 'SCATTER';
                STATE.focusTarget = null;
            }

            // åˆ·æ–°ç®¡ç†ç•Œé¢
            window.openDeleteManager();
        }

        // --- MediaPipe é›†æˆ ---
        async function initMediaPipe() {
            video = document.getElementById('webcam');
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO", numHands: 1
            });
            if (navigator.mediaDevices?.getUserMedia) {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => { document.getElementById('cam-status').classList.add('active'); predictWebcam(); });
            }
        }

        let lastVideoTime = -1;
        async function predictWebcam() {
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                if (handLandmarker) {
                    const result = handLandmarker.detectForVideo(video, performance.now());
                    processGestures(result);
                }
            }
            requestAnimationFrame(predictWebcam);
        }

        // --- æ‰‹åŠ¿é€»è¾‘æ ¸å¿ƒ ---
        function processGestures(result) {
            const hint = document.getElementById('gesture-hint');
            
            if (result.landmarks && result.landmarks.length > 0) {
                STATE.hand.detected = true;
                const lm = result.landmarks[0];
                STATE.hand.x = (lm[9].x - 0.5) * 2; 
                STATE.hand.y = (lm[9].y - 0.5) * 2;

                const thumb = lm[4]; const index = lm[8]; const wrist = lm[0];
                const pinchDist = Math.hypot(thumb.x - index.x, thumb.y - index.y);
                const tips = [lm[8], lm[12], lm[16], lm[20]];
                let openDist = 0; tips.forEach(t => openDist += Math.hypot(t.x - wrist.x, t.y - wrist.y)); openDist /= 4;

                if (pinchDist < 0.05) {
                    hint.innerText = "çŠ¶æ€: æŠ“å– / æŸ¥çœ‹";
                    
                    if (STATE.mode !== 'FOCUS') {
                        const photos = particleSystem.filter(p => p.type === 'PHOTO');
                        let closestPhoto = null;
                        let minScreenDist = Infinity;

                        photos.forEach(p => {
                            p.mesh.updateMatrixWorld();
                            const pos = new THREE.Vector3();
                            p.mesh.getWorldPosition(pos);
                            const screenPos = pos.project(camera); 

                            const dist = Math.hypot(screenPos.x, screenPos.y);
                            
                            if (screenPos.z < 1 && dist < CONFIG.interaction.grabRadius && dist < minScreenDist) {
                                minScreenDist = dist;
                                closestPhoto = p.mesh;
                            }
                        });

                        if (closestPhoto) {
                            STATE.mode = 'FOCUS';
                            STATE.focusTarget = closestPhoto;
                        }
                    }
                } 
                else if (openDist < 0.25) {
                    STATE.mode = 'TREE'; STATE.focusTarget = null;
                    hint.innerText = "çŠ¶æ€: èšåˆ (åœ£è¯æ ‘)";
                } 
                else if (openDist > 0.4) {
                    STATE.mode = 'SCATTER'; STATE.focusTarget = null;
                    hint.innerText = "çŠ¶æ€: æ•£å¼€ (ç§»åŠ¨æ‰‹è‡³è¾¹ç¼˜æ—‹è½¬)";
                }
            } else {
                STATE.hand.detected = false;
                hint.innerText = "ç­‰å¾…æ‰‹åŠ¿...";
            }
        }

        // --- åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();

            if (STATE.mode === 'SCATTER' && STATE.hand.detected) {
                const threshold = 0.3;
                const speed = CONFIG.interaction.rotationSpeed;
                
                if (STATE.hand.x > threshold) {
                    STATE.rotation.y += speed * dt * (STATE.hand.x - threshold);
                } else if (STATE.hand.x < -threshold) {
                    STATE.rotation.y += speed * dt * (STATE.hand.x + threshold);
                }

                if (STATE.hand.y > threshold) {
                    STATE.rotation.x += speed * dt * (STATE.hand.y - threshold);
                } else if (STATE.hand.y < -threshold) {
                    STATE.rotation.x += speed * dt * (STATE.hand.y + threshold);
                }
            } else {
                if(STATE.mode === 'TREE') {
                    STATE.rotation.y += 0.3 * dt;
                    STATE.rotation.x += (0 - STATE.rotation.x) * 2.0 * dt;
                } else {
                     STATE.rotation.y += 0.1 * dt;
                }
            }

            mainGroup.rotation.y = STATE.rotation.y;
            mainGroup.rotation.x = STATE.rotation.x;

            particleSystem.forEach(p => p.update(dt, STATE.mode, STATE.focusTarget));
            composer.render();
        }

        // åˆå§‹åŒ–
        init();
    </script>
</body>

</html>
